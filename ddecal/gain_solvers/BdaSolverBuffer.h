// Copyright (C) 2020 ASTRON (Netherlands Institute for Radio Astronomy)
// SPDX-License-Identifier: GPL-3.0-or-later

#ifndef DDECAL_BDA_SOLVER_BUFFER_H
#define DDECAL_BDA_SOLVER_BUFFER_H

#include "../../base/BDABuffer.h"

#include <aocommon/queue.h>

#include <cmath>
#include <complex>
#include <memory>
#include <vector>

namespace dp3 {
namespace ddecal {

class BdaSolverBuffer {
 public:
  /**
   * Constructor.
   * @param n_directions The number of directions.
   * @param start Start time of the first solution interval.
   * @param interval Length of a solution interval. Should be > 0.0.
   */
  BdaSolverBuffer(size_t n_directions, double start, double interval,
                  size_t n_baselines)
      : data_(),
        time_start_(start),
        time_interval_(interval),
        current_interval_(0),
        last_complete_interval_per_baseline_(n_baselines, -1),
        data_rows_() {
    assert(interval >= 0.0);
    AddInterval(
        n_directions);  // Ensure that the current solution interval is valid.
  }

  /**
   * This function takes a buffer with unweighted data and the corresponding
   * weights, and a buffer with model data. It weights these data buffers
   * and stores the result internally.
   * @param data_buffer A buffer with unweighted data and weights.
   * @param model_buffers A vector with model_buffers for each direction.
   * The BDA layout of these buffers should match the layout of the data_buffer.
   * The BdaSolverBuffer takes ownership of the model buffers.
   * @throw std::invalid_argument If model_buffers has an invalid size.
   */
  void AppendAndWeight(
      std::unique_ptr<base::BDABuffer> data_buffer,
      std::vector<std::unique_ptr<base::BDABuffer>>&& model_buffers);

  /**
   * Clears all internal buffers.
   * Does not affect the solution interval and the number of directions.
   */
  void Clear();

  /**
   * @return True if the current solution interval is complete. An interval
   * is complete if the solver buffer contains a BDA row with a start time
   * greater or equal to the end time of the current solution interval.
   */
  bool IntervalIsComplete() const {
    return *std::min_element(last_complete_interval_per_baseline_.begin(),
                             last_complete_interval_per_baseline_.end()) >= 0;
  }

  /**
   * Advances the current solution interval to the next interval.
   * Releases all internal buffers that only hold data for previous solution
   * intervals.
   */
  void AdvanceInterval();

  /**
   * Get the number of active buffers, which is the number of AppendAndWeight()
   * calls minus the number of buffers that AdvanceInterval() released.
   * @return The number of active buffers.
   */
  size_t BufferCount() const { return data_.Size(); }

  /**
   * Get the data for the current solution interval.
   * @return Non-modifyable rows with weighted visibilities.
   */
  const std::vector<const base::BDABuffer::Row*>& GetDataRows() const {
    return data_rows_[0].weighted;
  }

  /**
   * @return The absolute index of the current solution interval.
   */
  int GetCurrentInterval() const { return current_interval_; }

  /**
   * Get the model data rows for the current solution interval.
   * @param direction Direction index.
   * @return Rows with weighted model data.
   */
  const std::vector<const base::BDABuffer::Row*>& GetModelDataRows(
      size_t direction) const {
    return data_rows_[0].model[direction];
  }

  /**
   * Apply solutions to the predicted model and subtract the result from the
   * (unweighted) input data buffer, which was supplied to AppendAndWeight.
   * @param solutions Solutions generated by a BdaSolver.
   * @param chan_block_start_freqs Start frequencies for each channel block.
   * This vector has (n_channel_blocks + 1) items: The start frequency of a
   * block is the end frequency of the previous block.
   * @param n_polarizations Number of polarizations in the solution. Should be
   * 1, 2 or 4.
   * @param ant1 For each baseline, the index of the first antenna.
   * @param ant2 For each baseline, the index of the second antenna.
   * @param chan_freqs For each baseline, the center frequencies of all BDA
   * rows.
   */
  void SubtractCorrectedModel(
      const std::vector<std::vector<std::complex<double>>>& solutions,
      const std::vector<double>& chan_block_start_freqs, size_t n_polarizations,
      const std::vector<int>& ant1, const std::vector<int>& ant2,
      const std::vector<std::vector<double>>& chan_freqs);

  /**
   * Retrieve all unweighted input buffers which only hold data for previous
   * solution intervals. The BdaSolverBuffer is done processing those buffers.
   * The BdaSolverBuffer returns the buffers in the same order as they were
   * added using AppendAndWeight().
   * @return A possibly empty list of processed unweighted input buffers.
   */
  std::vector<std::unique_ptr<base::BDABuffer>> GetDone() {
    std::vector<std::unique_ptr<base::BDABuffer>> result;
    result.swap(done_);
    return result;
  }

 private:
  void AddInterval(size_t n_directions);

  /**
   * @param time_center Center time of a measurement / BDA row.
   * @return The relative solution interval index for a given time.
   */
  int RelativeIndex(double time_center) const {
    return int(std::floor((time_center - time_start_) / time_interval_)) -
           current_interval_;
  }

  /**
   * The BDASolverBuffer is the owner of both the unweighted and the weighted
   * input data. The data flow is:
   * 1. AppendAndWeight receives unweighted data, weights it, and stores both
   *    the unweighted and the corresponding weighted data in data_.
   * 2. A Solver accesses the weighted data via GetDataRows and
   *    GetModelDataRows, via a SolveData structure.
   * 3. SubtractCorrectedModel() applies the solutions to the model data and
   *    subtracts them from the unweighted data.
   * 4. When a BDA buffer is no longer needed, AdvanceInterval deletes the
   *    weighted data and moves the unweighted data to done_.
   * 5. GetDone() extracts the buffers from done_.
   */
  struct InputData {
    std::unique_ptr<base::BDABuffer> unweighted;
    std::unique_ptr<base::BDABuffer> weighted;
    /// Model data buffer for each direction.
    std::vector<std::unique_ptr<base::BDABuffer>> model;
  };

  /// A FIFO queue with input data. AppendAndWeight appends items.
  aocommon::Queue<InputData> data_;

  /// Fully processed input buffers.
  std::vector<std::unique_ptr<base::BDABuffer>> done_;

  /// Start time of the first solution interval (seconds).
  const double time_start_;
  const double time_interval_;  ///< Solution interval length (seconds).
  int current_interval_;  ///< Absolute index of the current solution interval.

  /// Index of the last complete solution interval per each baseline, relative
  /// to the current solution interval. The value is negative if no interval is
  /// complete.
  std::vector<int> last_complete_interval_per_baseline_;

  struct IntervalRows {
    std::vector<base::BDABuffer::Row*> unweighted;
    std::vector<const base::BDABuffer::Row*> weighted;
    std::vector<std::vector<const base::BDABuffer::Row*>> model;
  };

  /// The data rows for the current and future solution intervals.
  /// The queue always contains one element for the current solution interval.
  aocommon::Queue<IntervalRows> data_rows_;
};

}  // namespace ddecal
}  // namespace dp3

#endif  // DDECAL_BDA_SOLVER_BUFFER_H
